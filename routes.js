const express = require('express');
const { v4: uuidv4 } = require('uuid');
const db = require('./database');
const QRCode = require('qrcode');
const PDFDocument = require('pdfkit');
const { Parser } = require('json2csv');

const router = express.Router();

// --- Helpers ---
const getMeeting = (id) => db.prepare('SELECT * FROM meetings WHERE id = ?').get(id);
const verifyAdmin = (id, secret) => {
    const meeting = getMeeting(id);
    return meeting && meeting.admin_secret === secret;
};

// --- Routes ---

// 1. Create Meeting
router.post('/meetings', (req, res) => {
    const { title } = req.body;
    if (!title) return res.status(400).json({ error: 'Title is required' });

    const id = uuidv4();
    const admin_secret = uuidv4(); // Simple secret key

    try {
        db.prepare('INSERT INTO meetings (id, title, admin_secret) VALUES (?, ?, ?)')
            .run(id, title, admin_secret);

        res.json({ id, title, admin_secret, status: 'PENDING' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: 'Failed to create meeting' });
    }
});

// 2. Get Meeting Info (Public)
router.get('/meetings/:id', (req, res) => {
    const meeting = getMeeting(req.params.id);
    if (!meeting) return res.status(404).json({ error: 'Meeting not found' });

    // Do NOT return admin_secret
    res.json({ id: meeting.id, title: meeting.title, status: meeting.status, created_at: meeting.created_at });
});

// 3. Update Status (Admin Only)
router.post('/meetings/:id/status', (req, res) => {
    const { status, admin_secret } = req.body;
    const { id } = req.params;

    if (!verifyAdmin(id, admin_secret)) {
        return res.status(403).json({ error: 'Invalid Admin Secret' });
    }

    if (!['PENDING', 'ACTIVE', 'ENDED'].includes(status)) {
        return res.status(400).json({ error: 'Invalid status' });
    }

    db.prepare('UPDATE meetings SET status = ? WHERE id = ?').run(status, id);
    res.json({ success: true, status });
});

// 4. Submit Attendance
router.post('/attend', (req, res) => {
    console.log(`[POST /attend] Received request from ${req.body.name}`);
    const { meeting_id, name, signature, ip_hash } = req.body;

    if (!meeting_id || !name || !signature) {
        console.log(`[POST /attend] Missing fields`);
        return res.status(400).json({ error: 'Missing fields' });
    }

    const meeting = getMeeting(meeting_id);
    if (!meeting) return res.status(404).json({ error: 'Meeting not found' });
    if (meeting.status !== 'ACTIVE') return res.status(403).json({ error: 'Meeting is not accepting attendance' });

    // Basic Duplicate Check (IP Hash based) - Optional but good
    // Only check if ip_hash is provided
    if (ip_hash) {
        const existing = db.prepare('SELECT id FROM attendees WHERE meeting_id = ? AND ip_hash = ?').get(meeting_id, ip_hash);
        if (existing) {
            // We can either block or just update. For strictly one-time, blocking is safer against spam.
            // But in a real room, multiple people might be on same WiFi IP.
            // So maybe we strictly rely on Name? But names can be same.
            // Let's rely on Client LocalStorage to prevent accidental re-submit, 
            // and here maybe allow IP duplicates (WiFi scenario) but maybe limit rate?
            // For now, let's NOT block by IP to avoid blocking WiFi users, but we store it for audit.
            // Let's block if the exact NAME + Meeting ID exists? No, two "John Smith"s possible.
            // Design says: "Prevent basic duplicate submissions (device/IP based)"
            // Let's strictly block if SAME ip_hash submitted within last 1 minute? Or just block same IP entirely?
            // The user requirements said "Prevent basic duplicate submissions".
            // Let's return a warning if IP exists but allow? No, "locks records".
            // Let's stick to LocalStorage on frontend for UX, and here we just accept. 
            // Wait, requirement: "Prevent basic duplicate submissions (device/IP based)"
            // Okay, I will check if (ip_hash and meeting_id) exists, reject. 
            // BUT this breaks checking on same WiFi. 
            // Compromise: Check if Name AND IP match? 
            // Let's just implement it; if user complains about WiFi, we fix.
            // Actually, a unique device ID generated by frontend stored in cookie/localstorage is better 'ip_hash' substitute.
            // I will assume 'ip_hash' is a browser-fingerprint carried by client.

            if (existing) return res.status(409).json({ error: 'You have already signed in.' });
        }
    }

    const id = uuidv4();
    try {
        db.prepare('INSERT INTO attendees (id, meeting_id, name, signature, ip_hash) VALUES (?, ?, ?, ?, ?)')
            .run(id, meeting_id, name, signature, ip_hash);
        res.json({ success: true, id });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: 'Submission failed' });
    }
});

// 5. Get Attendees (Admin Only)
router.get('/meetings/:id/attendees', (req, res) => {
    const { id } = req.params;
    const { admin_secret } = req.query; // Passed as query param for GET

    if (!verifyAdmin(id, admin_secret)) {
        return res.status(403).json({ error: 'Invalid Admin Secret' });
    }

    const attendees = db.prepare('SELECT id, name, timestamp, signature FROM attendees WHERE meeting_id = ? ORDER BY timestamp DESC').all(id);
    res.json(attendees);
});

// 6. Export PDF (Admin Only)
router.get('/meetings/:id/export/pdf', async (req, res) => {
    const { id } = req.params;
    const { admin_secret } = req.query;

    if (!verifyAdmin(id, admin_secret)) return res.status(403).send('Unauthorized');
    const meeting = getMeeting(id);
    const attendees = db.prepare('SELECT * FROM attendees WHERE meeting_id = ? ORDER BY name ASC').all(id);

    const doc = new PDFDocument();
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="attendance-${meeting.title}.pdf"`);

    doc.pipe(res);

    // Title
    doc.fontSize(20).text(meeting.title, { align: 'center' });
    doc.fontSize(12).text(`Date: ${meeting.created_at}`, { align: 'center' });
    doc.moveDown();

    // Table Header
    doc.fontSize(12).text('Name', 50, doc.y, { continued: true });
    doc.text('Time', 250, doc.y, { continued: true });
    doc.text('Signature', 400, doc.y);
    doc.moveDown();
    doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
    doc.moveDown(0.5);

    // Rows
    for (const p of attendees) {
        const y = doc.y;
        doc.text(p.name, 50, y, { width: 180 });
        doc.text(new Date(p.timestamp).toLocaleTimeString(), 250, y);

        // Render signature image
        if (p.signature && p.signature.startsWith('data:image')) {
            try {
                doc.image(p.signature, 400, y - 10, { fit: [100, 30] });
            } catch (e) {
                doc.text('(Invalid Sig)', 400, y);
            }
        }
        doc.moveDown(2); // Space for signature
        if (doc.y > 700) doc.addPage();
    }

    doc.end();
});

// 7. Export CSV (Admin Only)
router.get('/meetings/:id/export/csv', (req, res) => {
    const { id } = req.params;
    const { admin_secret } = req.query;

    if (!verifyAdmin(id, admin_secret)) return res.status(403).send('Unauthorized');
    const meeting = getMeeting(id);
    const attendees = db.prepare('SELECT name, timestamp, id FROM attendees WHERE meeting_id = ?').all(id);

    try {
        const parser = new Parser({ fields: ['name', 'timestamp', 'id'] });
        const csv = parser.parse(attendees);
        res.header('Content-Type', 'text/csv');
        res.attachment(`attendance-${meeting.title}.csv`);
        return res.send(csv);
    } catch (err) {
        return res.status(500).send('Error generating CSV');
    }
});

module.exports = router;
